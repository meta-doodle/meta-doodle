/*
 * generated by Xtext 2.19.0
 */
package org.xtext.mdl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.mdl.services.V1GrammarAccess;
import org.xtext.mdl.v1.CondFin;
import org.xtext.mdl.v1.Contenu;
import org.xtext.mdl.v1.Depot;
import org.xtext.mdl.v1.Etape;
import org.xtext.mdl.v1.Mail;
import org.xtext.mdl.v1.Objet;
import org.xtext.mdl.v1.QCM;
import org.xtext.mdl.v1.Rappel;
import org.xtext.mdl.v1.SynchDate;
import org.xtext.mdl.v1.TypeQCM;
import org.xtext.mdl.v1.V1Package;
import org.xtext.mdl.v1.Workflow;

@SuppressWarnings("all")
public class V1SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private V1GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == V1Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case V1Package.COND_FIN:
				sequence_CondFin(context, (CondFin) semanticObject); 
				return; 
			case V1Package.CONTENU:
				sequence_Contenu(context, (Contenu) semanticObject); 
				return; 
			case V1Package.DEPOT:
				sequence_Depot(context, (Depot) semanticObject); 
				return; 
			case V1Package.ETAPE:
				sequence_Etape(context, (Etape) semanticObject); 
				return; 
			case V1Package.MAIL:
				sequence_Mail(context, (Mail) semanticObject); 
				return; 
			case V1Package.OBJET:
				sequence_Objet(context, (Objet) semanticObject); 
				return; 
			case V1Package.QCM:
				sequence_QCM(context, (QCM) semanticObject); 
				return; 
			case V1Package.RAPPEL:
				sequence_Rappel(context, (Rappel) semanticObject); 
				return; 
			case V1Package.SYNCH_DATE:
				sequence_SynchDate(context, (SynchDate) semanticObject); 
				return; 
			case V1Package.TYPE_QCM:
				sequence_TypeQCM(context, (TypeQCM) semanticObject); 
				return; 
			case V1Package.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CondFin returns CondFin
	 *
	 * Constraint:
	 *     date=DATE
	 */
	protected void sequence_CondFin(ISerializationContext context, CondFin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, V1Package.Literals.COND_FIN__DATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, V1Package.Literals.COND_FIN__DATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCondFinAccess().getDateDATETerminalRuleCall_0(), semanticObject.getDate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Contenu returns Contenu
	 *
	 * Constraint:
	 *     (corps=STRING | invitation=STRING)+
	 */
	protected void sequence_Contenu(ISerializationContext context, Contenu semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Depot returns Depot
	 *
	 * Constraint:
	 *     (intitule=STRING limiteSize=INT format+=STRING*)
	 */
	protected void sequence_Depot(ISerializationContext context, Depot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Etape returns Etape
	 *
	 * Constraint:
	 *     (id=ID name=STRING rappels+=Rappel* obj=Objet)
	 */
	protected void sequence_Etape(ISerializationContext context, Etape semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Mail returns Mail
	 *
	 * Constraint:
	 *     (expediteur=ADDRESSEMAIL destinataire+=ADDRESSEMAIL+ pj=STRING? corps=Contenu)
	 */
	protected void sequence_Mail(ISerializationContext context, Mail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Objet returns Objet
	 *
	 * Constraint:
	 *     ((obj=QCM cond=CondFin) | (mail=Mail dateEnvoi=DATE) | (synchDate=SynchDate cond=CondFin) | dateFin=DATE | depot=Depot)
	 */
	protected void sequence_Objet(ISerializationContext context, Objet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QCM returns QCM
	 *
	 * Constraint:
	 *     (type=TypeQCM intitule=STRING responses+=STRING* suite=QCM?)
	 */
	protected void sequence_QCM(ISerializationContext context, QCM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rappel returns Rappel
	 *
	 * Constraint:
	 *     (date=DATE mail=Mail)
	 */
	protected void sequence_Rappel(ISerializationContext context, Rappel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, V1Package.Literals.RAPPEL__DATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, V1Package.Literals.RAPPEL__DATE));
			if (transientValues.isValueTransient(semanticObject, V1Package.Literals.RAPPEL__MAIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, V1Package.Literals.RAPPEL__MAIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRappelAccess().getDateDATETerminalRuleCall_0_0(), semanticObject.getDate());
		feeder.accept(grammarAccess.getRappelAccess().getMailMailParserRuleCall_1_0(), semanticObject.getMail());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchDate returns SynchDate
	 *
	 * Constraint:
	 *     (start=DATE end=DATE precision=STRING?)
	 */
	protected void sequence_SynchDate(ISerializationContext context, SynchDate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeQCM returns TypeQCM
	 *
	 * Constraint:
	 *     (OPENQUESTION='OpenQuestion' | CHECKBOX='CheckBox' | RADIOBUTTON='RadioButton')
	 */
	protected void sequence_TypeQCM(ISerializationContext context, TypeQCM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Workflow returns Workflow
	 *
	 * Constraint:
	 *     ((dateDebut=DATE etapes+=Etape+) | etapes+=Etape+)?
	 */
	protected void sequence_Workflow(ISerializationContext context, Workflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
